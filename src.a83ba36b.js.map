{"version":3,"sources":["data.js","index.js"],"names":["ACRONYMS","ARTICLES","MATCH_TYPES","null","object","array","Array","isArray","boolean","constructor","name","string","number","isNaN","collection","MATCH_STRING","color","match","date","test","Date","toISOString","email","module","exports","require","itemConstructor","parseText","text","check","type","toString","parseObject","spec","Object","keys","map","key","parseType","parseArray","value","stringType","Error","parseLabel","words","w","parseMisc","join","includes","toLowerCase","toUpperCase","slice","processJSON","jsonObj","withLabel","other","label","item"],"mappings":";AAAA,IAAMA,EAAW,CAAC,KAAM,MAAO,OAAQ,OAAQ,MAAO,KAAM,MAAO,MAAO,MAAO,MAAO,MAAO,KAAM,MAAO,MAAO,MAAO,OAAQ,MAAO,MAAO,MAAO,MAAO,MAExJC,EAAW,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,OAAQ,KAAM,MAAO,KAAM,MAElFC,EAAc,CAClBC,KAAM,SAACC,GAAWA,OAAW,OAAXA,GAClBC,MAAO,SAACD,GAAWE,OAAAA,MAAMC,QAAQH,IACjCI,QAAS,SAACJ,GAAWA,MAA4B,YAA5BA,EAAOK,YAAYC,MACxCC,OAAQ,SAACP,GAAWA,MAA4B,WAA5BA,EAAOK,YAAYC,MACvCE,OAAQ,SAACR,GAAW,OAACS,OAAOT,IAC5BU,WAAY,SAACV,GAAWA,MAA4B,WAA5BA,EAAOK,YAAYC,OAGvCK,EAAe,CACnBC,MAAO,SAACL,GAAW,QAAEA,EAAOM,MAAM,wCAClCC,KAAM,SAACP,GAAW,MAAA,6CAA6CQ,KAAKR,IAC9D,IAAIS,KAAKT,GAASU,gBAAkBV,GAC1CW,MAAO,SAACX,GAAW,QAAEA,EAAOM,MAAM,+CAGpCM,OAAOC,QAAU,CACfxB,SAAAA,EACAC,SAAAA,EACAC,YAAAA,EACAa,aAAAA;;ACsHF,SAAA,EAAA,EAAA,GAAA,IAAA,EAAA,OAAA,KAAA,GAAA,GAAA,OAAA,sBAAA,CAAA,IAAA,EAAA,OAAA,sBAAA,GAAA,IAAA,EAAA,EAAA,OAAA,SAAA,GAAA,OAAA,OAAA,yBAAA,EAAA,GAAA,cAAA,EAAA,KAAA,MAAA,EAAA,GAAA,OAAA,EAAA,SAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,UAAA,OAAA,IAAA,CAAA,IAAA,EAAA,MAAA,UAAA,GAAA,UAAA,GAAA,GAAA,EAAA,EAAA,EAAA,OAAA,IAAA,GAAA,QAAA,SAAA,GAAA,EAAA,EAAA,EAAA,EAAA,MAAA,OAAA,0BAAA,OAAA,iBAAA,EAAA,OAAA,0BAAA,IAAA,EAAA,OAAA,IAAA,QAAA,SAAA,GAAA,OAAA,eAAA,EAAA,EAAA,OAAA,yBAAA,EAAA,MAAA,OAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,KAAA,EAAA,OAAA,eAAA,EAAA,EAAA,CAAA,MAAA,EAAA,YAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,GAAA,EAAA,EAzIIU,IA+GAC,EA/GAD,EAAAA,QAAQ,UAJVzB,EAAAA,EAAAA,SACAC,EAAAA,EAAAA,SACAC,EAAAA,EAAAA,YACAa,EAAAA,EAAAA,aAkBIY,EAAY,SAACC,GACZ,IAAA,IAAIC,KAASd,EACZA,GAAAA,EAAac,GAAOD,GACf,MAAA,CAAEE,KAAMD,EAAME,YAGlB,MAAA,CAAED,KAAM,SAQXE,EAAc,SAAC5B,GACZ,MAAA,CACL0B,KAAM,aACNG,KAAMC,OAAOC,KAAK/B,GACfgC,IAAI,SAACC,GAAQX,OAAAA,EAAgBW,EAAKC,EAAUlC,EAAOiC,SASpDE,EAAa,SAAClC,GACX,MAAA,CACLyB,KAAM,QACNG,KAAMK,EAAUjC,EAAM,MASpBiC,EAAY,SAACE,GACZ,IAAA,IAAIX,KAAS3B,EACZA,GAAAA,EAAY2B,GAAOW,GAAQ,CACvBC,IAAAA,EAAaZ,EAAME,WACrBU,MAAe,WAAfA,EACKd,EAAUa,GACO,UAAfC,EACFF,EAAWC,GACM,eAAfC,EACFT,EAAYQ,GACK,SAAfC,EACF,CAAEX,KAAM,QAER,CAAEA,KAAMD,EAAME,YAIrB,MAAA,IAAIW,MAAM,2BASZC,EAAa,SAACjC,GAGXkC,OADOlC,EAAKO,MADL,oCAEDmB,IAAI,SAAAS,GAAKC,OAAAA,EAAUD,KAAIE,KAAK,MAQrCD,EAAY,SAACnC,GACbV,OAAAA,EAAS+C,SAASrC,EAAOsC,eACpBtC,EAAOsC,cACLjD,EAASgD,SAASrC,EAAOuC,eAC3BvC,EAAOuC,cAGVvC,EAAOuC,gBAAkBvC,EAAeA,EACrCA,EAAO,GAAGuC,cAAgBvC,EAAOwC,MAAM,GAAGF,eAkB/CG,EAAc,SAACC,GAASC,IAAAA,EAAU,UAAA,OAAA,QAAA,IAAA,UAAA,IAAA,UAAA,GAc/BpB,OAZLR,EADE4B,EACgB,SAACjB,EAAKkB,GAAN,OAAA,EAAA,CAChB7C,KAAM2B,EACNmB,MAAOb,EAAWN,IACfkB,IAGa,SAAClB,EAAKkB,GAAN,OAAA,EAAA,CAChB7C,KAAM2B,GACHkB,IAIArB,OAAOC,KAAKkB,GAChBjB,IAAI,SAAAqB,GAAQ/B,OAAAA,EAAgB+B,EAAMnB,EAAUe,EAAQI,QAGzDlC,OAAOC,QAAQ4B,YAAcA","file":"src.a83ba36b.js","sourceRoot":"../src","sourcesContent":["const ACRONYMS = ['ID', 'URL', 'JSON', 'HTML', 'PDF', 'IP', 'SMS', 'ISO', 'ZIP', 'AMP', 'ISP', 'OS', 'IOS', 'UTM', 'UTC', 'GDPR', 'API', 'VAT', 'IVR', 'MRR', 'PO'];\n\nconst ARTICLES = ['at', 'by', 'to', 'on', 'in', 'of', 'for', 'from', 'or', 'via', 'be', 'is'];\n\nconst MATCH_TYPES = {\n  null: (object) => object === null,\n  array: (object) => Array.isArray(object),\n  boolean: (object) => object.constructor.name === 'Boolean',\n  string: (object) => object.constructor.name === 'String',\n  number: (object) => !isNaN(+object),\n  collection: (object) => object.constructor.name === 'Object',\n}\n\nconst MATCH_STRING = {\n  color: (string) => !!string.match(/^#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/g),\n  date: (string) => /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z/.test(string)\n    && (new Date(string)).toISOString() === string,\n  email: (string) => !!string.match(/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$/gi)\n}\n\nmodule.exports = {\n  ACRONYMS,\n  ARTICLES,\n  MATCH_TYPES,\n  MATCH_STRING\n}\n","const {\n  ACRONYMS,\n  ARTICLES,\n  MATCH_TYPES,\n  MATCH_STRING\n} = require('./data');\n\n/**\n * Item for interfaces and parameters\n * @typedef {Object} IntegrationItem\n * @property {string} Name\n * @property {string} Label\n * @property {string} Type\n * @property {*} [spec]\n * @property {*} [options]\n */\n\n/**\n * Parses type of the string\n * @param {string} text\n * @return {{type: string}}\n */\nconst parseText = (text) => {\n  for (let check in MATCH_STRING) {\n    if (MATCH_STRING[check](text)) {\n      return { type: check.toString() };\n    }\n  }\n  return { type: 'text' };\n}\n\n/**\n * Parses object type values\n * @param {*} object\n * @return {{type: string, spec: *[]}}\n */\nconst parseObject = (object) => {\n  return {\n    type: 'collection',\n    spec: Object.keys(object)\n      .map((key) => itemConstructor(key, parseType(object[key])))\n  };\n}\n\n/**\n * Parses values with array type, even with objects inside\n * @param {*[]} array\n * @return {{type: string, spec: *[] | Object}}\n */\nconst parseArray = (array) => {\n  return {\n    type: 'array',\n    spec: parseType(array[0])\n  };\n}\n\n/**\n * Parses type of passed value accordingly to prod docs\n * @param {*} value\n * @return {*}\n */\nconst parseType = (value) => {\n  for (let check in MATCH_TYPES) {\n    if (MATCH_TYPES[check](value)) {\n      const stringType = check.toString();\n      if (stringType === 'string') {\n        return parseText(value);\n      } else if (stringType === 'array') {\n        return parseArray(value);\n      } else if (stringType === 'collection') {\n        return parseObject(value);\n      } else if (stringType === 'null') {\n        return { type: 'text' };\n      } else {\n        return { type: check.toString() };\n      }\n    }\n  }\n  throw new Error('Invalid property type.');\n}\n\n/**\n * Label parser. Divides camelCase, PascalCase,\n * snake_case and other cases by words.\n * @param {string} name\n * @return {string}\n */\nconst parseLabel = (name) => {\n  const regex = /(\\d*[A-Z]*\\d*[a-zA-Z]\\d*[a-z]*)/g;\n  const words = name.match(regex);\n  return words.map(w => parseMisc(w)).join(' ');\n}\n\n/**\n * Parses miscellaneous\n * @param {string} string\n * @return {string}\n */\nconst parseMisc = (string) => {\n  if (ARTICLES.includes(string.toLowerCase())) {\n    return string.toLowerCase();\n  } else if (ACRONYMS.includes(string.toUpperCase())) {\n    return string.toUpperCase();\n  } else {\n    // check if word initially in uppercase\n    if (string.toUpperCase() === string) return string;\n    return string[0].toUpperCase() + string.slice(1).toLowerCase();\n  }\n}\n\n/**\n * Constructor function for single item\n * @param {string} key\n * @param {*} other - contains type and misc prop, like spec or options\n * @return {{name, label, type}}\n */\nlet itemConstructor;\n\n/**\n *\n * @param {*} jsonObj\n * @param {boolean} withLabel\n * @return {IntegrationItem[]}\n */\nconst processJSON = (jsonObj, withLabel=false) => {\n  if (withLabel) {\n    itemConstructor = (key, other) => ({\n      name: key,\n      label: parseLabel(key),\n      ...other,\n    });\n  } else {\n    itemConstructor = (key, other) => ({\n      name: key,\n      ...other,\n    });\n  }\n\n  return Object.keys(jsonObj)\n    .map(item => itemConstructor(item, parseType(jsonObj[item])));\n}\n\nmodule.exports.processJSON = processJSON;\n"]}