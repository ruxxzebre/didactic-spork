{"version":3,"sources":["match.js","assets/exclusions.json","constants.js","index.js"],"names":["MATCH_TYPES","null","object","undefined","Error","array","Array","isArray","boolean","string","constructor","name","number","isNaN","collection","MATCH_STRING","color","match","date","test","Date","toISOString","email","module","exports","acronyms","articles","CASE_REGEX","require","itemConstructor","parseText","text","check","type","toString","parseObject","spec","Object","keys","map","key","parseType","parseArray","length","value","stringType","parseLabel","words","filter","Boolean","w","parseMisc","join","includes","toLowerCase","toUpperCase","slice","cleanJson","jsonObj","processJSON","withLabel","other","label","item"],"mappings":"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","file":"src.b29a3e0d.js","sourceRoot":"../src","sourcesContent":["const MATCH_TYPES = {\n  null: (object) => object === null,\n  undefined: (object) => {\n    if (object === undefined)\n      throw new Error('Value is undefined. Probably empty value passed in function somewhere.');\n    return false;\n  },\n  array: (object) => Array.isArray(object),\n  boolean: (object) => object === !!object,\n  string: (object) => object.constructor.name === 'String',\n  number: (object) => !isNaN(+object),\n  collection: (object) => object.constructor.name === 'Object',\n}\n\nconst MATCH_STRING = {\n  color: (string) => !!string.match(/^#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/g),\n  date: (string) => /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z/.test(string)\n    && (new Date(string)).toISOString() === string,\n  email: (string) => !!string.match(/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$/gi)\n}\n\nmodule.exports = {\n  MATCH_TYPES,\n  MATCH_STRING\n}\n","module.exports={acronyms:[\"HTTP\",\"HTTPS\",\"ID\",\"URL\",\"JSON\",\"HTML\",\"PDF\",\"IP\",\"SMS\",\"ISO\",\"ZIP\",\"AMP\",\"ISP\",\"OS\",\"IOS\",\"UTM\",\"UTC\",\"GDPR\",\"API\",\"VAT\",\"IVR\",\"MRR\",\"PO\"],articles:[\"at\",\"by\",\"to\",\"on\",\"in\",\"of\",\"for\",\"from\",\"or\",\"via\",\"be\",\"is\"]};","const CASE_REGEX = /(\\d*[A-Z]*\\d*[a-zA-Z]\\d*[a-z]*)|(\\d*)/g;\n\nmodule.exports = {\n  CASE_REGEX\n};\n","const {\n  MATCH_TYPES,\n  MATCH_STRING\n} = require('./match');\n\nconst { acronyms, articles } = require('./assets/exclusions.json');\nconst { CASE_REGEX } = require('./constants');\n\n/**\n * Item for interfaces and parameters\n * @typedef {Object} IntegrationItem\n * @property {string} Name\n * @property {string} Label\n * @property {string} Type\n * @property {*} [spec]\n * @property {*} [options]\n */\n\n/**\n * Parses type of the string\n * @param {string} text\n * @return {{type: string}}\n */\nconst parseText = (text) => {\n  for (let check in MATCH_STRING) {\n    if (MATCH_STRING[check](text)) {\n      return { type: check.toString() };\n    }\n  }\n  return { type: 'text' };\n}\n\n/**\n * Parses object type values\n * @param {*} object\n * @return {{type: string, spec: *}}\n */\nconst parseObject = (object) => {\n  return {\n    type: 'collection',\n    spec: Object.keys(object)\n      .map((key) => itemConstructor(key, parseType(object[key])))\n  };\n}\n\n/**\n * Parses values with array type, even with objects inside\n * @param {*} array\n * @return {{type: string, spec: * | Object}}\n */\nconst parseArray = (array) => {\n  return {\n    type: 'array',\n    spec: array.length ? parseType(array[0]) : parseType(\"string\")\n  };\n}\n\n/**\n * Parses type of passed value accordingly to prod docs\n * @param {*} value\n * @return {*}\n */\nconst parseType = (value) => {\n  for (let check in MATCH_TYPES) {\n    if (MATCH_TYPES[check](value)) {\n      const stringType = check.toString();\n      if (stringType === 'string') {\n        return parseText(value);\n      } else if (stringType === 'array') {\n        return parseArray(value);\n      } else if (stringType === 'collection') {\n        return parseObject(value);\n      } else if (stringType === 'null') {\n        return { type: 'text' };\n      } else {\n        return { type: check.toString() };\n      }\n    }\n  }\n  throw new Error('Invalid property type.');\n}\n\n/**\n * Label parser. Divides camelCase, PascalCase,\n * snake_case and other cases by words.\n * @param {string} name\n * @return {string}\n */\nconst parseLabel = (name) => {\n  const words = name.match(CASE_REGEX);\n  return words.filter(Boolean).map(w => parseMisc(w)).join(' ');\n}\n\n/**\n * Parses miscellaneous\n * @param {string} string\n * @return {string}\n */\nconst parseMisc = (string) => {\n  if (articles.includes(string.toLowerCase())) {\n    return string.toLowerCase();\n  } else if (acronyms.includes(string.toUpperCase())) {\n    return string.toUpperCase();\n  } else {\n    // check if word initially in uppercase\n    if (string.toUpperCase() === string) return string;\n    return string[0].toUpperCase() + string.slice(1).toLowerCase();\n  }\n}\n\n/**\n * Constructor function for single item\n * @param {string} key\n * @param {*} other - contains type and misc prop, like spec or options\n * @return {{name, label, type}}\n */\nlet itemConstructor;\n\n/**\n * Cleans JSON from array wrapper\n * @param jsonObj Initial JSON object\n * @return {*} Cleaned JSON object\n */\nconst cleanJson = (jsonObj) => {\n  if (MATCH_TYPES.array(jsonObj) && jsonObj.length === 1) {\n    return jsonObj[0];\n  } else if (MATCH_TYPES.collection(jsonObj)) {\n    return jsonObj;\n  } else {\n    throw new Error(`Invalid JSON passed. \n      Probably it\\`s array with multiple items. \n      Only Object or Object wrapped in array are valid input.`);\n  }\n};\n\n/**\n *\n * @param {*} jsonObj\n * @param {boolean} withLabel\n * @return {IntegrationItem[]}\n */\nconst processJSON = (jsonObj, withLabel = false) => {\n  jsonObj = cleanJson(jsonObj);\n  if (withLabel) {\n    itemConstructor = (key, other) => ({\n      name: key,\n      label: parseLabel(key),\n      ...other,\n    });\n  } else {\n    itemConstructor = (key, other) => ({\n      name: key,\n      ...other,\n    });\n  }\n\n  return Object.keys(jsonObj)\n    .map(item => itemConstructor(item, parseType(jsonObj[item])));\n}\n\nmodule.exports.processJSON = processJSON;\n"]}