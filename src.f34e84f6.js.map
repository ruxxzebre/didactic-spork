{"version":3,"sources":["match.js","assets/exclusions.json","constants.js","index.js"],"names":["MATCH_TYPES","null","object","undefined","Error","array","Array","isArray","boolean","string","constructor","name","number","isNaN","collection","MATCH_STRING","color","match","date","test","Date","toISOString","email","module","exports","acronyms","articles","CASE_REGEX","require","ItemConstructor","parseText","text","check","type","toString","parseObject","spec","Object","keys","map","key","parseType","parseArray","length","value","stringType","parseLabel","words","filter","Boolean","w","i","parseMisc","join","index","upFirstLetter","first","rest","toUpperCase","includes","toLowerCase","NewItemConstructor","includeLabel","other","label","cleanJson","jsonObj","ParseFormattedParameters","json","withLabel","fields","validFlag","obj","validateParam","parsedLabel","processJSON","formatted","item"],"mappings":"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","file":"src.f34e84f6.js","sourceRoot":"../src","sourcesContent":["const MATCH_TYPES = {\n  null: (object) => object === null,\n  undefined: (object) => {\n    if (object === undefined)\n      throw new Error('Value is undefined. Probably empty value passed in function somewhere.');\n    return false;\n  },\n  array: (object) => Array.isArray(object),\n  boolean: (object) => object === !!object,\n  string: (object) => object.constructor.name === 'String',\n  number: (object) => !isNaN(+object),\n  collection: (object) => object.constructor.name === 'Object',\n}\n\nconst MATCH_STRING = {\n  color: (string) => !!string.match(/^#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/g),\n  date: (string) => /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z/.test(string)\n    && (new Date(string)).toISOString() === string,\n  email: (string) => !!string.match(/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$/gi)\n}\n\nmodule.exports = {\n  MATCH_TYPES,\n  MATCH_STRING\n}\n","module.exports={acronyms:[\"HTTP\",\"HTTPS\",\"ID\",\"URL\",\"JSON\",\"HTML\",\"PDF\",\"IP\",\"SMS\",\"ISO\",\"ZIP\",\"AMP\",\"ISP\",\"OS\",\"IOS\",\"UTM\",\"UTC\",\"GDPR\",\"API\",\"VAT\",\"IVR\",\"MRR\",\"PO\"],articles:[\"at\",\"by\",\"to\",\"on\",\"in\",\"of\",\"for\",\"from\",\"or\",\"via\",\"be\",\"is\"]};","const CASE_REGEX = /(\\d*[A-Z]*\\d*[a-zA-Z]\\d*[a-z]*)|(\\d*)/g;\n\nmodule.exports = {\n  CASE_REGEX\n};\n","const {\n  MATCH_TYPES,\n  MATCH_STRING\n} = require('./match');\n\nconst { acronyms, articles } = require('./assets/exclusions.json');\nconst { CASE_REGEX } = require('./constants');\n\n/**\n * Item for interfaces and parameters\n * @typedef {Object} IntegrationItem\n * @property {string} Name\n * @property {string} Label\n * @property {string} Type\n * @property {*} [spec]\n * @property {*} [options]\n */\n\n/**\n * Parses type of the string\n * @param {string} text\n * @return {{type: string}}\n */\nconst parseText = (text) => {\n  for (let check in MATCH_STRING) {\n    if (MATCH_STRING[check](text)) {\n      return { type: check.toString() };\n    }\n  }\n  return { type: 'text' };\n}\n\n/**\n * Parses object type values\n * @param {*} object\n * @return {{type: string, spec: *}}\n */\nconst parseObject = (object) => {\n  return {\n    type: 'collection',\n    spec: Object.keys(object)\n      .map((key) => ItemConstructor(key, parseType(object[key])))\n  };\n}\n\n/**\n * Parses values with array type, even with objects inside\n * @param {*} array\n * @return {{type: string, spec: * | Object}}\n */\nconst parseArray = (array) => {\n  return {\n    type: 'array',\n    spec: array.length ? parseType(array[0]) : parseType(\"string\")\n  };\n}\n\n/**\n * Parses type of passed value accordingly to prod docs\n * @param {*} value\n * @return {*}\n */\nconst parseType = (value) => {\n  for (let check in MATCH_TYPES) {\n    if (MATCH_TYPES[check](value)) {\n      const stringType = check.toString();\n      if (stringType === 'string') {\n        return parseText(value);\n      } else if (stringType === 'array') {\n        return parseArray(value);\n      } else if (stringType === 'collection') {\n        return parseObject(value);\n      } else if (stringType === 'null') {\n        return { type: 'text' };\n      } else {\n        return { type: check.toString() };\n      }\n    }\n  }\n  throw new Error('Invalid property type.');\n}\n\n/**\n * Label parser. Divides camelCase, PascalCase,\n * snake_case and other cases by words.\n * @param {string} name\n * @return {string}\n */\nconst parseLabel = (name) => {\n  const words = name.match(CASE_REGEX);\n  return words.filter(Boolean).map((w, i) => parseMisc(w, i)).join(' ');\n}\n\n/**\n * Parses miscellaneous\n * @param {string} string\n * @return {string}\n */\nconst parseMisc = (string, index) => {\n  const upFirstLetter = ([first, ...rest]) => first.toUpperCase() + rest.join('');\n\n  if (index === 0) return upFirstLetter(string);\n  if (articles.includes(string.toLowerCase())) {\n    return string.toLowerCase();\n  } else if (acronyms.includes(string.toUpperCase())) {\n    return string.toUpperCase();\n  }\n  // check if word initially in uppercase\n  if (string.toUpperCase() === string) return string;\n  return upFirstLetter(string);\n\n}\n\n/**\n * Constructor function for single item\n * @function ItemConstructor\n * @param {string} key\n * @param {*} other - contains type and misc prop, like spec or options\n * @return {{name, label, type}}\n */\nlet ItemConstructor;\n\n/**\n *\n * @param {boolean} includeLabel\n * @return ItemConstructor\n */\nconst NewItemConstructor = (includeLabel) => (key, other) => {\n  return {\n    name: key,\n    ...includeLabel && ({label: parseLabel(key)}),\n    ...other,\n  };\n}\n\n/**\n * Cleans JSON from array wrapper\n * @param jsonObj Initial JSON object\n * @return {*} Cleaned JSON object\n */\nconst cleanJson = (jsonObj) => {\n  if (MATCH_TYPES.array(jsonObj) && jsonObj.length === 1) {\n    return jsonObj[0];\n  } else if (MATCH_TYPES.collection(jsonObj)) {\n    return jsonObj;\n  } else {\n    throw new Error(`Invalid JSON passed. \n      Probably it\\`s array with multiple items. \n      Only Object or Object wrapped in array are valid input.`);\n  }\n};\n\nconst ParseFormattedParameters = (json, withLabel) => {\n  const fields = [\n    'name', 'label', 'type', 'help', 'required', 'default', 'advanced', 'options', 'spec'\n  ];\n  const stabilityConf = -3;\n  const validateParam = (obj) => {\n    const keys = Object.keys(obj);\n    const cb = (i) => fields.includes(i);\n    return keys.filter(cb).length === keys.length;\n  };\n  let validFlag = true;\n  if (json.constructor.name !== 'Array') return null;\n  json = json.map(obj => {\n    if (!validateParam(obj)) return validFlag = false;\n    if (obj.name) {\n      if (!obj.label || withLabel) {\n        const parsedLabel = parseLabel(obj.name);\n        if (obj.label && obj.label.length + stabilityConf < parsedLabel.length) {\n          obj.label = parsedLabel;\n        }\n      }\n      return obj;\n    }\n    validFlag = false;\n  });\n  return validFlag ? json : null;\n};\n\n/**\n *\n * @param {*} jsonObj\n * @param {boolean} withLabel\n * @return {IntegrationItem[]}\n */\nconst processJSON = (jsonObj, withLabel = false) => {\n  let formatted;\n  if (formatted = ParseFormattedParameters(jsonObj, withLabel)) return formatted;\n  jsonObj = cleanJson(jsonObj);\n  ItemConstructor = NewItemConstructor(withLabel);\n  return Object.keys(jsonObj)\n    .map(item => ItemConstructor(item, parseType(jsonObj[item])));\n}\n\nmodule.exports.processJSON = processJSON;\n"]}